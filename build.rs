//! Build script for compile-time LUT generation.
//!
//! Generates lookup tables into src/generated/ for:
//! - GAMMA_LUT: sRGB gamma decompression
//! - ECCENTRICITY_LUT: Hellwig eccentricity (Munsell-fitted)
//! - ECCENTRICITY_CAM16_LUT: CAM16 eccentricity
//! - HK_HUE_LUT: Helmholtz-Kohlrausch hue dependency
//! - CUSP_LUT: Gamut boundary cusps (J', M) per hue

use std::f64::consts::PI;
use std::fs;
use std::io::Write;
use std::path::Path;

use palette::cam16::{BakedParameters, Cam16Jmh, Parameters, StaticWp};
use palette::convert::IntoColorUnclamped;
use palette::white_point::D65;
use palette::{Srgb, Xyz};

fn main() {
    println!("cargo:rerun-if-changed=build.rs");

    let out_dir = Path::new("src/generated");
    fs::create_dir_all(out_dir).expect("Failed to create src/generated directory");

    generate_gamma_lut(out_dir);
    generate_eccentricity_lut(out_dir);
    generate_eccentricity_cam16_lut(out_dir);
    generate_hk_hue_lut(out_dir);
    generate_cusp_lut(out_dir);
    generate_mod_rs(out_dir);
}

/// Generate GAMMA_LUT: 256-entry [f64; 256] for (x/255.0)^2.4 (u8 inputs)
fn generate_gamma_lut(out_dir: &Path) {
    let path = out_dir.join("gamma_lut.rs");
    let mut file = fs::File::create(&path).expect("Failed to create gamma_lut.rs");

    writeln!(file, "// Gamma LUT for sRGB inverse companding.").unwrap();
    writeln!(file, "//").unwrap();
    writeln!(file, "// Generated by build.rs - do not edit manually.").unwrap();
    writeln!(file).unwrap();

    // 256-entry LUT for u8 inputs
    writeln!(file, "#[allow(clippy::excessive_precision)]").unwrap();
    writeln!(file, "/// Precomputed (x/255.0)^2.4 for x in 0..256").unwrap();
    writeln!(file, "pub static GAMMA_LUT: [f64; 256] = [").unwrap();

    for x in 0..256u32 {
        let value = (x as f64 / 255.0).powf(2.4);
        writeln!(file, "    {:.17},", value).unwrap();
    }

    writeln!(file, "];").unwrap();
    writeln!(file).unwrap();

    // 4096-entry LUT for f32 inputs (12-bit precision, ~0.00024 resolution)
    writeln!(file, "/// Resolution of GAMMA_LUT_F32 (number of entries)").unwrap();
    writeln!(file, "pub const GAMMA_LUT_F32_SIZE: usize = 4096;").unwrap();
    writeln!(file).unwrap();
    writeln!(file, "#[allow(clippy::excessive_precision)]").unwrap();
    writeln!(
        file,
        "/// Precomputed x^2.4 for x in [0.0, 1.0] with 4096 entries"
    )
    .unwrap();
    writeln!(file, "pub static GAMMA_LUT_F32: [f64; 4096] = [").unwrap();

    for i in 0..4096u32 {
        let x = i as f64 / 4095.0;
        let value = x.powf(2.4);
        writeln!(file, "    {:.17},", value).unwrap();
    }

    writeln!(file, "];").unwrap();
}

/// Generate ECCENTRICITY_LUT: 360-entry [f32; 360] for Hellwig eccentricity
fn generate_eccentricity_lut(out_dir: &Path) {
    let path = out_dir.join("eccentricity_lut.rs");
    let mut file = fs::File::create(&path).expect("Failed to create eccentricity_lut.rs");

    writeln!(file, "// Eccentricity LUT for Hellwig-Fairchild model.").unwrap();
    writeln!(file, "//").unwrap();
    writeln!(file, "// Generated by build.rs - do not edit manually.").unwrap();
    writeln!(file).unwrap();
    writeln!(file, "#[allow(clippy::excessive_precision)]").unwrap();
    writeln!(
        file,
        "/// Precomputed Hellwig eccentricity for hue angles 0..360 degrees"
    )
    .unwrap();
    writeln!(file, "pub static ECCENTRICITY_LUT: [f32; 360] = [").unwrap();

    for hue_deg in 0..360 {
        let hue_rad = (hue_deg as f64) * PI / 180.0;
        let value = eccentricity(hue_rad);
        writeln!(file, "    {:.10},", value as f32).unwrap();
    }

    writeln!(file, "];").unwrap();
}

/// Generate ECCENTRICITY_CAM16_LUT: 360-entry [f32; 360] for CAM16 eccentricity
fn generate_eccentricity_cam16_lut(out_dir: &Path) {
    let path = out_dir.join("eccentricity_cam16_lut.rs");
    let mut file = fs::File::create(&path).expect("Failed to create eccentricity_cam16_lut.rs");

    writeln!(file, "// CAM16 eccentricity LUT.").unwrap();
    writeln!(file, "//").unwrap();
    writeln!(file, "// Generated by build.rs - do not edit manually.").unwrap();
    writeln!(file).unwrap();
    writeln!(file, "#[allow(clippy::excessive_precision)]").unwrap();
    writeln!(
        file,
        "/// Precomputed CAM16 eccentricity for hue angles 0..360 degrees"
    )
    .unwrap();
    writeln!(file, "pub static ECCENTRICITY_CAM16_LUT: [f32; 360] = [").unwrap();

    for hue_deg in 0..360 {
        let hue_rad = (hue_deg as f64) * PI / 180.0;
        let value = eccentricity_cam16(hue_rad);
        writeln!(file, "    {:.10},", value as f32).unwrap();
    }

    writeln!(file, "];").unwrap();
}

/// Generate HK_HUE_LUT: 360-entry [f32; 360] for Helmholtz-Kohlrausch hue dependency
fn generate_hk_hue_lut(out_dir: &Path) {
    let path = out_dir.join("hk_hue_lut.rs");
    let mut file = fs::File::create(&path).expect("Failed to create hk_hue_lut.rs");

    writeln!(file, "// Helmholtz-Kohlrausch hue dependency LUT.").unwrap();
    writeln!(file, "//").unwrap();
    writeln!(file, "// Generated by build.rs - do not edit manually.").unwrap();
    writeln!(file).unwrap();
    writeln!(file, "#[allow(clippy::excessive_precision)]").unwrap();
    writeln!(
        file,
        "/// Precomputed HK hue angle dependency for hue angles 0..360 degrees"
    )
    .unwrap();
    writeln!(file, "pub static HK_HUE_LUT: [f32; 360] = [").unwrap();

    for hue_deg in 0..360 {
        let hue_rad = (hue_deg as f64) * PI / 180.0;
        let value = hue_angle_dependency(hue_rad);
        writeln!(file, "    {:.10},", value as f32).unwrap();
    }

    writeln!(file, "];").unwrap();
}

/// Generate mod.rs that re-exports all LUTs
fn generate_mod_rs(out_dir: &Path) {
    let path = out_dir.join("mod.rs");
    let mut file = fs::File::create(&path).expect("Failed to create mod.rs");

    writeln!(file, "//! Generated lookup tables.").unwrap();
    writeln!(file, "//!").unwrap();
    writeln!(file, "//! Generated by build.rs - do not edit manually.").unwrap();
    writeln!(file).unwrap();
    writeln!(file, "include!(\"gamma_lut.rs\");").unwrap();
    writeln!(file, "include!(\"eccentricity_lut.rs\");").unwrap();
    writeln!(file, "include!(\"eccentricity_cam16_lut.rs\");").unwrap();
    writeln!(file, "include!(\"hk_hue_lut.rs\");").unwrap();
    writeln!(file, "include!(\"cusp_lut.rs\");").unwrap();
}

// LUT computation functions (copied from hellwig.rs to avoid dependencies)

/// Hellwig eccentricity (Munsell-fitted Fourier series)
fn eccentricity(hue_rad: f64) -> f64 {
    let h = hue_rad;
    let h2 = 2.0 * h;
    let h3 = 3.0 * h;
    let h4 = 4.0 * h;

    -0.0582 * h.cos() - 0.0258 * h2.cos() - 0.1347 * h3.cos() + 0.0289 * h4.cos()
        - 0.1475 * h.sin()
        - 0.0308 * h2.sin()
        + 0.0385 * h3.sin()
        + 0.0096 * h4.sin()
        + 1.0
}

/// CAM16 eccentricity
fn eccentricity_cam16(hue_rad: f64) -> f64 {
    0.25 * ((hue_rad + 2.0).cos() + 3.8)
}

/// Helmholtz-Kohlrausch hue angle dependency
fn hue_angle_dependency(hue_rad: f64) -> f64 {
    let h = hue_rad;
    let h2 = 2.0 * h;

    -0.160 * h.cos() + 0.132 * h2.cos() - 0.405 * h.sin() + 0.080 * h2.sin() + 0.792
}

// Cusp LUT generation

/// Default viewing parameters for CAM16 (same as runtime)
fn default_params() -> BakedParameters<StaticWp<D65>, f64> {
    let adapting_luminance = 64.0 / PI * 0.2;
    Parameters::default_static_wp(adapting_luminance).bake()
}

/// Convert HellwigJmh to sRGB (f64 precision for build-time accuracy)
fn hellwig_to_srgb(lightness: f64, colorfulness: f64, hue_deg: f64) -> (f64, f64, f64) {
    let hue_rad = hue_deg * PI / 180.0;

    // Reverse HK effect
    let chroma = colorfulness * 35.0 / 100.0;
    let hk_factor = hue_angle_dependency(hue_rad);
    let lightness_base = lightness - hk_factor * chroma.powf(0.587);

    // Reverse eccentricity correction
    let e_ratio = eccentricity_cam16(hue_rad) / eccentricity(hue_rad);
    let colorfulness_cam16 = colorfulness * e_ratio;

    // Convert via CAM16 -> XYZ -> sRGB (unclamped to detect out-of-gamut)
    let cam16 = Cam16Jmh::new(lightness_base, colorfulness_cam16, hue_deg);
    let params = default_params();
    let xyz: Xyz<D65, f64> = cam16.into_xyz(params);
    let srgb: Srgb<f64> = Srgb::from_linear(xyz.into_color_unclamped());

    (srgb.red, srgb.green, srgb.blue)
}

/// Check if HellwigJmh color is within sRGB gamut
fn is_in_gamut(lightness: f64, colorfulness: f64, hue_deg: f64) -> bool {
    let (r, g, b) = hellwig_to_srgb(lightness, colorfulness, hue_deg);
    (0.0..=1.0).contains(&r) && (0.0..=1.0).contains(&g) && (0.0..=1.0).contains(&b)
}

/// Find maximum in-gamut colorfulness at given (J', h) using binary search
fn find_max_m_at_jh(j: f64, hue_deg: f64) -> f64 {
    let mut lo = 0.0;
    let mut hi = 120.0;

    while hi - lo > 0.01 {
        let mid = (lo + hi) / 2.0;
        if is_in_gamut(j, mid, hue_deg) {
            lo = mid;
        } else {
            hi = mid;
        }
    }
    lo
}

/// Compute cusp (J', M) for a given hue
fn compute_cusp(hue_deg: f64) -> (f64, f64) {
    let mut best_j = 50.0;
    let mut best_m = 0.0;

    // Coarse search: J' from 10 to 95 in steps of 1
    for j_int in 10..=95 {
        let j = j_int as f64;
        let m_max = find_max_m_at_jh(j, hue_deg);
        if m_max > best_m {
            best_m = m_max;
            best_j = j;
        }
    }

    // Fine search around best_j
    let j_lo = (best_j - 2.0).max(5.0);
    let j_hi = (best_j + 2.0).min(98.0);

    let steps = 40;
    for i in 0..=steps {
        let j = j_lo + (j_hi - j_lo) * (i as f64 / steps as f64);
        let m_max = find_max_m_at_jh(j, hue_deg);
        if m_max > best_m {
            best_m = m_max;
            best_j = j;
        }
    }

    (best_j, best_m)
}

/// Generate CUSP_LUT: 360-entry [(f32, f32); 360] for gamut cusp points
fn generate_cusp_lut(out_dir: &Path) {
    let path = out_dir.join("cusp_lut.rs");
    let mut file = fs::File::create(&path).expect("Failed to create cusp_lut.rs");

    writeln!(file, "// Cusp LUT for gamut mapping.").unwrap();
    writeln!(file, "//").unwrap();
    writeln!(file, "// Generated by build.rs - do not edit manually.").unwrap();
    writeln!(file).unwrap();
    writeln!(file, "#[allow(clippy::excessive_precision)]").unwrap();
    writeln!(
        file,
        "/// Precomputed (J'_cusp, M_cusp) pairs for hue angles 0..360 degrees"
    )
    .unwrap();
    writeln!(file, "pub static CUSP_LUT: [(f32, f32); 360] = [").unwrap();

    for hue_deg in 0..360 {
        let (j_cusp, m_cusp) = compute_cusp(hue_deg as f64);
        writeln!(file, "    ({:.6}, {:.6}),", j_cusp as f32, m_cusp as f32).unwrap();
    }

    writeln!(file, "];").unwrap();
}
